## 命名空间的using声明

有了using声明就无须专门的前缀（形如命名空间::）也能使用所需的名字了。using声明具有如下的形式：
`using namespace::name;`

#### 每个名字都需要独立的using声明

C++语言的形式比较自由，因此既可以一行只放一条using声明语句，也可以一行放上多条。不过要注意，用到的每个名字都必须有自己的声明语句，而且每句话都得以分号结束。

#### 头文件不应该包含using声明

头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。

## 标准库类型string

标准库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。

> C++标准一方面对库类型所提供的操作做了详细规定，另一方面也对库的实现者做出一些性能上的需求。因此，标准库类型对于一般应用场合来说有足够的效率。

```
string s1 默认初始化，s1是一个空串
string s2(s1) s2是s1的副本
string s2 = s1 等价于s2(s1)，s2是s1的副本
string s3("value") s3是字面值“value”的副本，除了字面值最后的那个空字符外
string s3 = "value" 等价于s3("value")，s3是字面值“value”的副本
string s4(10, 'c') 把s4初始化为由连续n个字符c组成的串
```

#### 直接初始化和拷贝初始化

C++语言有几种不同的初始化方式。如果使用等号（=）初始化一个变量，实际上执行的是 **拷贝初始化（copy initialization）**，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是 **直接初始化（direct initialization）**。

### string对象上的操作

```
os<<s 将s写到输出流os当中，返回os
is>>s 从is中读取字符串赋给s，字符串以空白分隔，返回is
getline(is, s) 从is中读取一行赋给s，返回is
s.empty() s为空返回true，否则返回false
s.size() 返回s中字符的个数
s[n] 返回s中第n个字符的引用，位置n从0计起
s1+s2 返回s1和s2连接后的结果
s1=s2 用s2的副本代替s1中原来的字符
s1==s2 如果s1和s2中所含的字符完全一样，则它们相等；string对象的相等性判断对字母的大小写敏感
s1!=s2
<，<=，>，>= 利用字符在字典中的顺序进行比较，且对字母的大小写敏感
```

> 触发getline函数返回的那个换行符实际上被丢弃掉了，得到的string对象中并不包含该换行符。

#### string的empty和size操作

empty函数根据string对象是否为空返回一个对应的布尔值。

size函数返回string对象的长度。

#### string::size_type类型

size函数返回的是一个string::size_type类型的值。

string类及其他大多数标准库都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性，类型 **size_type** 即是其中的一种。在具体使用的时候，通过作用域操作符来表明名字size_type是在类string中定义的。

