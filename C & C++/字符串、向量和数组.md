## 命名空间的using声明

有了using声明就无须专门的前缀（形如命名空间::）也能使用所需的名字了。using声明具有如下的形式：
`using namespace::name;`

#### 每个名字都需要独立的using声明

C++语言的形式比较自由，因此既可以一行只放一条using声明语句，也可以一行放上多条。不过要注意，用到的每个名字都必须有自己的声明语句，而且每句话都得以分号结束。

#### 头文件不应该包含using声明

头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。

## 标准库类型string

标准库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。

> C++标准一方面对库类型所提供的操作做了详细规定，另一方面也对库的实现者做出一些性能上的需求。因此，标准库类型对于一般应用场合来说有足够的效率。

```
string s1 默认初始化，s1是一个空串
string s2(s1) s2是s1的副本
string s2 = s1 等价于s2(s1)，s2是s1的副本
string s3("value") s3是字面值“value”的副本，除了字面值最后的那个空字符外
string s3 = "value" 等价于s3("value")，s3是字面值“value”的副本
string s4(10, 'c') 把s4初始化为由连续n个字符c组成的串
```

#### 直接初始化和拷贝初始化

C++语言有几种不同的初始化方式。如果使用等号（=）初始化一个变量，实际上执行的是 **拷贝初始化（copy initialization）**，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是 **直接初始化（direct initialization）**。

### string对象上的操作

```
os<<s 将s写到输出流os当中，返回os
is>>s 从is中读取字符串赋给s，字符串以空白分隔，返回is
getline(is, s) 从is中读取一行赋给s，返回is
s.empty() s为空返回true，否则返回false
s.size() 返回s中字符的个数
s[n] 返回s中第n个字符的引用，位置n从0计起
s1+s2 返回s1和s2连接后的结果
s1=s2 用s2的副本代替s1中原来的字符
s1==s2 如果s1和s2中所含的字符完全一样，则它们相等；string对象的相等性判断对字母的大小写敏感
s1!=s2
<，<=，>，>= 利用字符在字典中的顺序进行比较，且对字母的大小写敏感
```

> 触发getline函数返回的那个换行符实际上被丢弃掉了，得到的string对象中并不包含该换行符。

#### string的empty和size操作

empty函数根据string对象是否为空返回一个对应的布尔值。

size函数返回string对象的长度。

#### string::size_type类型

size函数返回的是一个string::size_type类型的值。

string类及其他大多数标准库都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性，类型 **size_type** 即是其中的一种。在具体使用的时候，通过作用域操作符来表明名字size_type是在类string中定义的。

所有用于存放string类的size函数返回值的变量，都应该是string::size_typ类型的。

在C++11新标准中，允许编译器通过auto或者decltype来推断变量的类型。

> 如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。

#### 比较string对象

1. 如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。
2. 如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。

#### 为string对象赋值

对于string类而言，允许把一个对象的值赋给另外一个对象。

#### 两个string对象相加

两个string对象相加得到一个新的string对象，其内容是把左侧的运算对象与右侧的运算对象串接而成。也就是说，对string对象使用加法运算符（+）的结果是一个新的string对象，它所包含的字符由两部分组成：前半部分是加号左侧string对象所含的字符、后半部分是加号右侧string对象所含的字符。另外，复合赋值运算符（+=）负责把右侧string对象的内容追加到左侧string对象的后面。

#### 字面值和string对象相加

即使一种类型并非所需，我们也可以使用它，不过前提是该种类型可以自动转换成所需的类型。因为标准库允许把字符字面值和字符串字面值转换成string对象，所以在需要string对象的地方就可以使用这两种字面值来替代。

> 因为某些历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型string的对象。切记，字符串字面值与string是不同的类型。

### 处理string对象中的字符

> 建议：使用C++版本的C标准库头文件
> C++标准库中除了定义C++语言特有的功能外，也兼容了C语言的标准库。C语言的头文件形如name.h，C++则将这些文件命名为cname。也就是去掉了.h后缀，而在文件名name之前添加了字母c，这里的c表示这是一个属于C语言标准库的头文件。
> 因此，cctype头文件和ctype.h头文件的内容是一样的，只不过从命名规范上来讲更符合C++语言的要求。特别的，在名为cname的头文件中定义的名字从属于命名空间std，而定义在名为.h的头文件中的则不然。
> 一般来说，C++程序应该使用名为cname的头文件而不使用name.h的形式，标准库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。

#### 处理每个字符？使用基于范围的for语句

如果相对string对象中的每个字符做点儿什么操作，目前最好的办法是使用C++11新标准提供的一种语句： **范围for（range for）** 语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作，其语法形式是：
```
for (declaration: expression)
	statement
```

#### 使用范围for语句改变字符串中的字符

如果想要改变string对象中字符的值，必须把循环变量定义成引用类型。记住，所谓引用只是给定对象的一个别名，因此当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变它绑定的字符。

#### 只处理一部分字符？

要想访问string对象中的单个字符有两种方式：一种是使用下标，另外一种是使用迭代器。

**下标运算符（[]）** 接收的输入参数是string::size_type类型的值，这个参数表示要访问的字符的位置；返回值是该位置上字符的引用。

> string对象的下标必须大于等于0而小于s.size()。
> 使用超出此范围的下标将引发不可预知的结果，以此推断，使用下标访问空string也会引发不可预知的结果。

下标的值称作“下标”或“索引”，任何表达式只要它的值是一个整型值就能作为索引。不过，如果某个索引是带符号类型的值将自动转换成由string::size_type表达的无符号类型。

> 提示：注意检查下标的合法性
> 使用下标时必须确保其在合理范围之内，也就是说，下标必须大于等于0而小于字符串的size()的值。一种简便易行的方法是，总是设下标的类型为string::size_type，因为此类型是无符号数，可以确保下标不会小于0。此时，代码只需保证下标小于size()的值就可以了。
> C++标准并不要求标准库检测下标是否合法。一旦使用了一个超出范围的下标，就会产生不可预知的结果。

## 标准库类型vector

