数据类型是程序的基础：它告诉我们数据的意义以及我们能在数据上执行的操作。
## 基本内置类型

C++定义了一套包括 **算术类型（arithmetic type）** 和  **空类型（void）** 在内的基本数据类型。其中算术类型包含了字符、整型数、布尔型和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。

### 算术类型

算术类型分为两类：**整型**（integral type，包括字符和布尔类型在内）和 **浮点型**。

|类型|含义|最小尺寸|
|:---:|:---:|:---:|
|bool|布尔类型|未定义|
|char|字符|8 bits|
|wchar_t|宽字符|16 bits|
|char16_t|Unicode字符|16 bits|
|char32_t|Unicode字符|32 bits|
|short|短整型|16 bits|
|int|整型|16 bits|
|long|长整型|32 bits|
|long long|长整型|64 bits|
|float|单精度浮点数|6位有效数字|
|double|双精度浮点数|10位有效数字|
|long double|扩展精度浮点数|10位有效数字|

### 带符号类型和无符号类型

除去布尔型和扩展的字符类型之外，其他整型可以划分为 **带符号的（signed）** 和 **无符号的（unsigned）** 两种。带符号类型可以表示正数、负数或0，无符号类型则仅能表示大于等于0的值。

类型int、short、long和long long都是带符号的，通过在这些类型名前面添加`unsigned` 就可以得到无符号类型，例如`unsigned long`。类型`unsigned int`可以缩写为`unsigned`。

与其他整型不同，字符型被分为了三种：char、signed char和unsigned char。特别需要注意的是：类型char和类型signed char并不一样。尽管字符类型有三种，但是字符的表现形式却只有两种：带符号和无符号的。类型char实际上会表现为上述两种形式种的一种，具体是哪种由编译器决定。

> 建议：如何选择类型
> C语言一样，C+的设计准则之一也是尽可能地接近硬件。C+的算术类型认须 满足各种要供特质，所以它们常常显得繁杂而令人不知所措。事实上，大多数程序员 参(也应该）对数据类型的使用做出限定从而“简化选择的过程。以下是选择类型的办一 经验准则：
> - 当明确知晓数值不可能为负时，选用无符号类型。
> - 使用int执行整数运算。在实际应用中，short常常显得太小而long一般和int有一样的尺寸。如果你的数值超过了int的表示范围，选用long long。
> - 在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的， 所以如果使用char进行运算特别容易出问题。如果你需要使用一个不大的整数， 那么明确指定它的类型是signed char或者unsigned char。
> - 执行浮点数运算选用double，这是因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。Iong double提供的精度在一般情况下是没有必要的， 况且它带来的运行时消耗也不容忽视。

### 类型转换

对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种给定的类型 **转换（convert）** 为另一种相关类型。

> 建议：避免无法预知和依赖于实现环境的行为
> 无法预知的行为源于编译器无须（有时是不能）检测的错误。即使代码编译通过了，如果程序执行了一条为定义的表达式，仍有可能产生错误。
> 不幸的是，在某些情况和/或某些编译器下，含有无法预知行为的程序也能正确执行。但是我们却无法保证同样一个程序在别的编译器下能正常工作，甚至已经编译通过的代码再次执行也可能会出错。此外，也不能认为这样的程序对一组输入有效，对另一组输入就一定有效。
> 程序也应该尽量避免依赖于实现环境的行为。如果我们把int的尺寸看成是一个确定不变的已知值，那么这样的程序就称作 *不可移植的（nonportable）* 。当程序移植到别的机器上后，依赖于实现环境的程序就可能发生错误。要从过去的代码中定位这类错误可不是一件轻松愉快的工作。

### 含有无符号类型的表达式

> 提示：切勿混用带符号类型和无符号类型
> 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。

### 字面值常量

一个形如 42 的值被称作 **字面值常量（literal）** ，这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

#### 整型和浮点型字面值

我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以 `0` 开头的整数代表八进制数，以 `0x` 或 `0X` 开头的代表十六进制数。

整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值即可能是带符号的也可能是无符号的。十进制字面值的类型是int、long和long long中尺寸最小的那个，当前前提是这种类型要容纳下当前的值。八进制和十六进制字面值的类型是容纳其数值的int、unsigned int、long、unsigned long、long long和unsigned long long中的尺寸最小者。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。类型short没有对应的字面值。

尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如果我们使用了一个形如-42的负十进制字面值，那个负号并不在字面值之内，它的作用仅仅是对字面值取负值而已。

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e标识。默认的，浮点型字面值是一个double，可以使用后缀来表示其他浮点型。

#### 字符和字符串字面值

由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。

字符串字面值的类型实际上是由常量字符构成的数组。

如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的方式。

#### 转义序列

有两类字符程序员不能直接使用：一类是 **不可打印（nonprintable）** 的字符，如退格或其他控制字符，因为它们没有可视的图符；另一类是在C++语言中有特殊含义的字符（单引号、双引号、问号、反斜线）。在这些情况下需要用到 **转义序列（escape sequence）** ，转义序列均以反斜线作为开始，C++语言规定的转义序列包括：

换行符 `\n`
横向制表符 `\t`
报警（响铃）符 `\a`
纵向制表符 `\v`
退格符 `\b`
双引号 `\"`
反斜线 `\\`
问号 `\?`
单引号 `\'`
回车符 `\n`
进纸符 `\f`

也可以使用泛化的转义序列，其形式是`\x`后紧跟1个或多个十六进制数字，或者`\`后紧跟1个、2个或3个八进制数字，其中数字部分表示的是字符对应的数值。

#### 指定字面值的类型

**字符和字符串**

|前缀|含义|类型|
|:-:|:-:|:-:|
|u|Unicode16字符|char16_t|
|U|Unicode32字符|char32_t|
|L|宽字符|wchar_t|
|u8|UTF-8（仅用于字符串字面常量）|char|

**整型字面值**

|后缀|最小匹配类型|
|:-:|:-:|
|u or U|unsigned|
|l or L|long|
|ll or LL|long long|

浮点型字面值

|后缀|类型|
|:-:|:-:|
|f or F|float|
|l or L|long double|

#### 布尔字面值和指针字面值

`true` 和 `false` 是布尔类型的字面值。
`nullptr` 是指针字面值。

## 变量

*变量* 提供一个具名的、可提供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。对C++程序员来说，“变量（variable）”和“对象（object）”一般可以互换使用。

### 变量定义

变量定义的基本形式是：首先是 **类型说明符（type specifier）**，随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分割，最后以分号结束。列表中每个变量名的类型都由类型说明符指定，定义时还可以为一个或多个变量赋初值。

> 术语：何为对象？
> C++程序员们在很多场合都会使用对象（object）这个名词。通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。

#### 初始值

当对象在创建时获得了一个特定的值，我们说这个对象被 **初始化（initialized）** 了。用于初始化变量的值可以是任意复杂的表达式。当一次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用了。因此在同一条定义语句中，可以用先定义的变量去初始化后定义的其他变量。

> 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

#### 列表初始化

C++语言定义了初始化的好几种不同形式，这也是初始化问题复杂性的一个体现。
```
int units_sold = 0;
int units_solld = {0};
int units_sold{0};
int units_sold(0);
```

作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用，而在此之前，这种初始化的形式仅在某些受限的场合下才能使用。这种初始化的形式被称为 **列表初始化（list initialization）** 。现在，无论是初始化对象还是某些时候为对象赋新值，都可以使用这样一组由花括号括起来的初始值了。

当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器报错。

#### 默认初始化

如果定义变量时没有指定初值，则变量被 **默认初始化（default initialized）** ，此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。

如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数内部的内置类型变量将 **不被初始化（uninitialized）**。一个未被初始化的内置类型变量的值是为定义的，如果试图拷贝或以其他形式访问此类值将引发错误。

定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式地初始化，则其值由类确定。

> 建议初始化每一个内置类型的变量。虽然并非必须这么做，但如果我们不能确保初始化后程序安全，那么这么做不失为一种简单可靠的方法。

### 变量声明和定义的关系

为了允许把程序拆分成多个逻辑部分来编写，C++语言支持 *分离式编译（separate compilation）* 机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。

如果将程序分为多个文件，则需要有在文件间共享代码的方法。

为了支持分离式编译，C++语言将声明和定义区分开来。 **声明（declaration）** 使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而 **定义（definition）** 负责创建与名字关联的实体。

变量声明规则定义了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字`extern`，而且不要显式地初始化变量。任何包含了显式初始化的声明即成为定义。

在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。

> 变量能且只能被定义一次，但是可以被多次声明。

> 关键概念：静态类型
> C++是一种静态类型（statically typed）语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查（type checking）。
> 我们已经知道，对象的类型决定了对象所能参与的运算。在C++语言中，编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。
> 程序越复杂，静态类型检查越有助于发现问题。然而，前提是编译器必须知道每一个实体对象的类型，这就要求我们在使用某个变量之前必须声明其类型。

### 标识符

C++的 *标识符（identifier）* 由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。

C++语言保留了一些名字提供语言本身使用，这些名字不能被用作标识符。

同时，C++也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外，定义的函数体外的标识符不能以下划线开头。

#### 变量命名规范

* 标识符要能体现实际含义。
* 变量名一般用小写字母。
* 用户自定义的类名一般以大写字母开头。
* 如果标识符又多个单词组成，则单词应有明显区分。

> 对于命名规范来说，若能坚持，必将有效。

**C++关键字**
```
alignas
alignof
asm
auto
bool
break
case
catch
char
char16_t
char32_t
class
const
constexpr
const_cast
continue
decltype
default
delete
do
double
dynamic_cast
else
enum
explicit
export
extern
false
float
for
friend
goto
if
inline
int
long
mutable
namespace
new
noexcept
nullptr
operator
private
protected
public
register
reinterpret_cast
return
short
signed
sizeof
static
static_assert
static_cast
struct
switch
template
this
thread_local
throw
true
try
typedef
typeid
typename
union
unsigned
using
virtual
void
volatile
wchar_t
while
```

**C++操作符替代名**
```
and
and_eq
bitand
bitor
compl
not
not_eq
or
or_eq
xor
xor_eq
```

### 名字的作用域

**作用域（scope）** 是程序的一部分，在其中名字有其特定的含义。C++语言中大多数作用域都以花括号分割。

同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。

全局作用域（global scope）
块作用域（block scope）
正在作用域内（in scope）

> 建议：当你第一次使用变量时再定义它
> 一般来说，在对象第一次被使用的地方附近定义它是一种好的选择，因为这样做有助于更容易地找到变量的定义。更重要的是，当变量的定义与它第一次被使用的地方很近时，我们也会赋给它一个比较合理的初始值。

> 如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。

## 复合类型

**复合类型（compound type）** 是指基于其他类型定义的类型。

一条声明语句由一个 **基本数据类型（base type）** 和紧随其后的一个 **声明符（declarator）** 列表组成的。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。

### 引用

**引用（reference）** 为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。

一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值 **绑定（bind）** 在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

#### 引用即别名

> 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。

#### 引用的定义

允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号`&`开头；引用的类型都要和与之绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。

### 指针

**指针（pointer）** 是“指向（point to）”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

定义指针类型的方法将声明符写成`*d*`的形式，其中`d`是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号`*`。

#### 获取对象的地址

指针存放某个对象的地址，要想获取该地址，需要使用 **取地址符（操作符&）**。

因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。

#### 指针值

指针的值（即地址）应属下列4种状态之一：

1. 指向一个对象。
2. 指向紧邻对象所占空间的下一个位置。
3. 空指针，意味着指针没有指向任何对象。
4. 无效指针，也就是上诉情况之外的其他值。

试图拷贝或以其他方式访问无效指针的值都将引发错误。

尽管第2种和第3种形式的指针是有效的，但其使用同样受到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。

#### 利用指针访问对象

如果指针指向了一个对象，则允许使用 **解引用符（操作符*）** 来访问该对象。

> 解引用操作仅适用于那些确实指向了某个对象的有效指针。

> 关键概念：某些符号有多重含义
> 像`&`和`*`这样的符号，即能用作表达式里的运算符，也能作为声明的一部分出现，符号的上下文决定了符号的意义。
> 在声明语句中，`&`和`*`用于组成复合类型；在表达式中，它们的角色又转变成运算符。在不同场景下出现的虽然是同一个符号，但是由于含义截然不同，所以我们完全可以把它当作不同的符号来看待。

#### 空指针

**空指针（null pointer）** 不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。

以下列出几个生成空指针的方法：

```
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL;
```

得到空指针最直接的办法就是用字面值 **nullptr** 来初始化指针，这也是C++新标准刚刚引入的一种方法。nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。另一种颁发就如对p2的定义一样，也可以通过将指针初始化字面值0来生成空指针。

过去的程序还会用到一个名为NULL的 **预处理变量（preprocessor variable）** 来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是0。

> 建议：初始化所有指针
> 使用未经初始化的指针是引发运行时错误的一大原因。
> 和其他变量一样，访问未经初始化的指针所引发的后果也是无法预计的。通常这一行为将造成程序崩溃，而且一旦崩溃，要想定位到出错位置将是特别棘手的问题。
> 在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的当前内容将被看作一个地址值。访问该指针，相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。
> 因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它没有指向任何具体的对象了。

#### 赋值和指针

指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上两者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其在绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。

指针和它存放的地址之间就没有这种限制了。和其他任何变量（只要不是引用）一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。

#### 其他指针操作

只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算术值作为条件准循的规则类似，如果指针的值是0，条件取false；任何非0指针对应的条件都是true。

对于两个类型相同的合法指针，可以用相同操作符（\=\=）或不相等操作符（!=）来比较他们，比较的结果是布尔类型。

如果两个指针存放的地址值相同，则它们相等；反之它们不相等。这里两个指针存放的地址相同（两个指针相同）有三种可能：它们都为空、都指向同一个对象，或者都指向了同一个对象的下一地址。

#### void* 指针

`void *` 是一种特殊的指针类型，可用于存放任意对象的地址。一个 `void*` 指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解。

不能直接操作`void *`指针所指的对象，因为我们并不知道这个对象到底是什么类型、也就无法确定能在这个对象上做那些操作。

概括来说，以 `void *` 的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象。

### 理解复合类型的声明

变量的定义包括一个基本数据类型（base type）和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。也就是说，一条定义语句可能定义出不同类型的变量。

> 很多程序员容易迷惑于基本数据类型和类型修饰符的关系，其实后者不过是声明符的一部分罢了。

#### 定义多个变量

涉及指针或引用的声明，一般有两种写法。第一种把修饰符和变量标识符写在一起：
```
int *p1, *p2;
```
这种形式着重强调变量具有的复合类型。第二种把修饰符和类型名写在一起，并且每条语句只定义一个变量：
```
int* p1;
int* p2;
```
这种形式着重强调本次声明定义了一种复合类型。

> 上述两种定义指针或引用的不同方法没有孰对孰错之分，关键是选择并坚持其中的一种写法，不要总是变来变去。

#### 指向指针的指针

一般来说，声明符中修饰符的个数并没有限制。当有多个修饰符连写在一起时，按照其逻辑关系详加解释即可。

通过`*`的个数可以区分指针的级别。也就是说，`**`表示指向指针的指针，`***`表示指向指针的指针的指针，依次类推。

#### 指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。

> 面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。

## const限定符

有时我们希望定义这样一种变量，它的值不能被改变。为了满足这一要求，可以用关键字`const`对变量的类型加以限定。因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。

#### 初始化和const

只能在const类型的 对象上执行不改变其内容的操作。

在不改变const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要。

#### 默认状态下，const对象仅在文件内有效

当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。

想让这类const对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义const，而在其他多个文件中声明并使用它。

解决的办法是，对于const变量不管是声明还是定义都添加extern关键字，这样只需要定义一次就可以了。

> 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。

### const的引用

可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为 **对常量的引用（reference to const）** 。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。

> 术语：常量引用是对const的引用
> C++程序员们经常把词组“对const的引用”简称为“常量引用”，这一简称还是挺靠谱的，不过前提是你得时刻记得这就是个简称而已。
> 严格来说，并不存在常量引用。因为引用不是一个对象，所以我们没法让引用本身恒定不变。事实上，由于C++语言并不允许随意改变引用所绑定的对象，所以从这层意义上理解所有的引用又都算是常量。引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系本身。

#### 初始化和对const的引用

引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。

**临时量（temporary）**

#### 对const的引用可能引用一个并非const的对象

### 指针和const

与引用一样，也可以令指针指向常量或非常量。类似于常量引用，**指向常量的指针（pointer to const）** 不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。

指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象。

和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。

> 试试这样想吧：所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。

#### const指针

指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。**常量指针（const pointer）** 必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。把`*`放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指针指向的那个值。

### 顶层const

指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词 **顶层const（top-level const）** 表示指针本身是个常量，而用名词 **底层const（low-level const）** 表示指针所指的对象是一个常量。

顶层const可以表示任意的对象是常量，这一点对任何数据类型都适合，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点和其他类型相比区别明显。

当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响，执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么影响。

另一方面，底层const的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。

### constexpr和常量表达式

**常量表达式（const expression）** 是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。

一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定。

#### constexpr变量

C++11新标规定，允许将变量声明为 **constexpr** 类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。

> 一般来说，如果你认定变量是一个常量表达式，那就把它声明为constexpr类型。

#### 字面值类型

常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”（literal type）。

算术类型、引用和指针都属于字面值类型。

尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。

#### 指针和constexpr

