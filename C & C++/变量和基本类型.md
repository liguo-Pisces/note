数据类型是程序的基础：它告诉我们数据的意义以及我们能在数据上执行的操作。
## 基本内置类型

C++定义了一套包括 **算术类型（arithmetic type）** 和  **空类型（void）** 在内的基本数据类型。其中算术类型包含了字符、整型数、布尔型和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。

### 算术类型

算术类型分为两类：**整型**（integral type，包括字符和布尔类型在内）和 **浮点型**。

|类型|含义|最小尺寸|
|:---:|:---:|:---:|
|bool|布尔类型|未定义|
|char|字符|8 bits|
|wchar_t|宽字符|16 bits|
|char16_t|Unicode字符|16 bits|
|char32_t|Unicode字符|32 bits|
|short|短整型|16 bits|
|int|整型|16 bits|
|long|长整型|32 bits|
|long long|长整型|64 bits|
|float|单精度浮点数|6位有效数字|
|double|双精度浮点数|10位有效数字|
|long double|扩展精度浮点数|10位有效数字|

### 带符号类型和无符号类型

除去布尔型和扩展的字符类型之外，其他整型可以划分为 **带符号的（signed）** 和 **无符号的（unsigned）** 两种。带符号类型可以表示正数、负数或0，无符号类型则仅能表示大于等于0的值。

类型int、short、long和long long都是带符号的，通过在这些类型名前面添加`unsigned` 就可以得到无符号类型，例如`unsigned long`。类型`unsigned int`可以缩写为`unsigned`。

与其他整型不同，字符型被分为了三种：char、signed char和unsigned char。特别需要注意的是：类型char和类型signed char并不一样。尽管字符类型有三种，但是字符的表现形式却只有两种：带符号和无符号的。类型char实际上会表现为上述两种形式种的一种，具体是哪种由编译器决定。

> 建议：如何选择类型
> C语言一样，C+的设计准则之一也是尽可能地接近硬件。C+的算术类型认须 满足各种要供特质，所以它们常常显得繁杂而令人不知所措。事实上，大多数程序员 参(也应该）对数据类型的使用做出限定从而“简化选择的过程。以下是选择类型的办一 经验准则：
> - 当明确知晓数值不可能为负时，选用无符号类型。
> - 使用int执行整数运算。在实际应用中，short常常显得太小而long一般和int有一样的尺寸。如果你的数值超过了int的表示范围，选用long long。
> - 在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的， 所以如果使用char进行运算特别容易出问题。如果你需要使用一个不大的整数， 那么明确指定它的类型是signed char或者unsigned char。
> - 执行浮点数运算选用double，这是因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。Iong double提供的精度在一般情况下是没有必要的， 况且它带来的运行时消耗也不容忽视。

### 类型转换

对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种给定的类型 **转换（convert）** 为另一种相关类型。

> 建议：避免无法预知和依赖于实现环境的行为
> 无法预知的行为源于编译器无须（有时是不能）检测的错误。即使代码编译通过了，如果程序执行了一条为定义的表达式，仍有可能产生错误。
> 不幸的是，在某些情况和/或某些编译器下，含有无法预知行为的程序也能正确执行。但是我们却无法保证同样一个程序在别的编译器下能正常工作，甚至已经编译通过的代码再次执行也可能会出错。此外，也不能认为这样的程序对一组输入有效，对另一组输入就一定有效。
> 程序也应该尽量避免依赖于实现环境的行为。如果我们把int的尺寸看成是一个确定不变的已知值，那么这样的程序就称作 *不可移植的（nonportable）* 。当程序移植到别的机器上后，依赖于实现环境的程序就可能发生错误。要从过去的代码中定位这类错误可不是一件轻松愉快的工作。

### 含有无符号类型的表达式

> 提示：切勿混用带符号类型和无符号类型
> 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。

### 字面值常量

一个形如 42 的值被称作 **字面值常量（literal）** ，这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

#### 整型和浮点型字面值

我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以 `0` 开头的整数代表八进制数，以 `0x` 或 `0X` 开头的代表十六进制数。

整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值即可能是带符号的也可能是无符号的。十进制字面值的类型是int、long和long long中尺寸最小的那个，当前前提是这种类型要容纳下当前的值。八进制和十六进制字面值的类型是容纳其数值的int、unsigned int、long、unsigned long、long long和unsigned long long中的尺寸最小者。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。类型short没有对应的字面值。

尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如果我们使用了一个形如-42的负十进制字面值，那个负号并不在字面值之内，它的作用仅仅是对字面值取负值而已。

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e标识。默认的，浮点型字面值是一个double，可以使用后缀来表示其他浮点型。

#### 字符和字符串字面值

由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。

字符串字面值的类型实际上是由常量字符构成的数组。

如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的方式。

#### 转义序列

有两类字符程序员不能直接使用：一类是 **不可打印（nonprintable）** 的字符，如退格或其他控制字符，因为它们没有可视的图符；另一类是在C++语言中有特殊含义的字符（单引号、双引号、问号、反斜线）。在这些情况下需要用到 **转义序列（escape sequence）** ，转义序列均以反斜线作为开始，C++语言规定的转义序列包括：

换行符 `\n`
横向制表符 `\t`
报警（响铃）符 `\a`
纵向制表符 `\v`
退格符 `\b`
双引号 `\"`
反斜线 `\\`
问号 `\?`
单引号 `\'`
回车符 `\n`
进纸符 `\f`

也可以使用泛化的转义序列，其形式是`\x`后紧跟1个或多个十六进制数字，或者`\`后紧跟1个、2个或3个八进制数字，其中数字部分表示的是字符对应的数值。

#### 指定字面值的类型

**字符和字符串**

|前缀|含义|类型|
|:-:|:-:|:-:|
|u|Unicode16字符|char16_t|
|U|Unicode32字符|char32_t|
|L|宽字符|wchar_t|
|u8|UTF-8（仅用于字符串字面常量）|char|

**整型字面值**

|后缀|最小匹配类型|
|:-:|:-:|
|u or U|unsigned|
|l or L|long|
|ll or LL|long long|

浮点型字面值

|后缀|类型|
|:-:|:-:|
|f or F|float|
|l or L|long double|

#### 布尔字面值和指针字面值

`true` 和 `false` 是布尔类型的字面值。
`nullptr` 是指针字面值。

## 变量

*变量* 提供一个具名的、可提供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。对C++程序员来说，“变量（variable）”和“对象（object）”一般可以互换使用。

### 变量定义

变量定义的基本形式是：首先是 **类型说明符（type specifier）**，随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分割，最后以分号结束。列表中每个变量名的类型都由类型说明符指定，定义时还可以为一个或多个变量赋初值。

> 术语：何为对象？
> C++程序员们在很多场合都会使用对象（object）这个名词。通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。

#### 初始值

当对象在创建时获得了一个特定的值，我们说这个对象被 **初始化（initialized）** 了。用于初始化变量的值可以是任意复杂的表达式。当一次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用了。因此在同一条定义语句中，可以用先定义的变量去初始化后定义的其他变量。

> 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

#### 列表初始化

C++语言定义了初始化的好几种不同形式，这也是初始化问题复杂性的一个体现。
```
int units_sold = 0;
int units_solld = {0};
int units_sold{0};
int units_sold(0);
```

作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用，而在此之前，这种初始化的形式仅在某些受限的场合下才能使用。这种初始化的形式被称为 **列表初始化（list initialization）** 。现在，无论是初始化对象还是某些时候为对象赋新值，都可以使用这样一组由花括号括起来的初始值了。

当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器报错。

#### 默认初始化

如果定义变量时没有指定初值，则变量被 **默认初始化（default initialized）** ，此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。

如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数内部的内置类型变量将 **不被初始化（uninitialized）**。一个未被初始化的内置类型变量的值是为定义的，如果试图拷贝或以其他形式访问此类值将引发错误。

定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式地初始化，则其值由类确定。

> 建议初始化每一个内置类型的变量。虽然并非必须这么做，但如果我们不能确保初始化后程序安全，那么这么做不失为一种简单可靠的方法。

### 变量声明和定义的关系

为了允许把程序拆分成多个逻辑部分来编写，C++语言支持 *分离式编译（separate compilation）* 机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。

如果将程序分为多个文件，则需要有在文件间共享代码的方法。

为了支持分离式编译，C++语言将声明和定义区分开来。 **声明（declaration）** 使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而 **定义（definition）** 负责创建与名字关联的实体。

变量声明规则定义了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字`extern`，而且不要显式地初始化变量。任何包含了显式初始化的声明即成为定义。

在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。

> 变量能且只能被定义一次，但是可以被多次声明。

> 关键概念：静态类型
> C++是一种静态类型（statically typed）语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查（type checking）。
> 我们已经知道，对象的类型决定了对象所能参与的运算。在C++语言中，编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。
> 程序越复杂，静态类型检查越有助于发现问题。然而，前提是编译器必须知道每一个实体对象的类型，这就要求我们在使用某个变量之前必须声明其类型。

### 标识符

C++的 *标识符（identifier）* 由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。

C++语言保留了一些名字提供语言本身使用，这些名字不能被用作标识符。

同时，C++也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外，定义的函数体外的标识符不能以下划线开头。

#### 变量命名规范

* 标识符要能体现实际含义。
* 变量名一般用小写字母。
* 用户自定义的类名一般以大写字母开头。
* 如果标识符又多个单词组成，则单词应有明显区分。

> 对于命名规范来说，若能坚持，必将有效。

**C++关键字**
```
alignas
alignof
asm
auto
bool
break
case
catch
char
char16_t
char32_t
class
const
constexpr
const_cast
continue
decltype
default
delete
do
double
dynamic_cast
else
enum
explicit
export
extern
false
float
for
friend
goto
if
inline
int
long
mutable
namespace
new
noexcept
nullptr
operator
private
protected
public
register
reinterpret_cast
return
short
signed
sizeof
static
static_assert
static_cast
struct
switch
template
this
thread_local
throw
true
try
typedef
typeid
typename
union
unsigned
using
virtual
void
volatile
wchar_t
while
```

**C++操作符替代名**
```
and
and_eq
bitand
bitor
compl
not
not_eq
or
or_eq
xor
xor_eq
```

